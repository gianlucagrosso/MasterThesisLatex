\chapter{Summary and outlook}
\label{chap:concl}

The work presented in this thesis expands the scope of tensor-train cross-approximation by introducing a patch-based, \textit{divide-et-impera} strategy.
Starting from the modern implementation of QTCI developed by Ritter \textit{et al.}, namely \texttt{TensorCrossInterpolation.jl}~\cite{TensorCrossInterpolation.jl} and
its quantics extensions \cite{tensor4all.org}, we have integrated a new layer of logic that adaptively partitions the input tensor into smaller subtensors, each compressed with a user-defined bond-dimension cap \(\chi_{\text{patch}}\).  This patched variant, \textit{pQTCI}, retains the logarithmic complexity of the original algorithm~\cite{Fernandez2024} while
addressing two long-standing bottlenecks: the explosive bond growth that plagues functions with narrow peaks, and the \(\chi^{\,4}\) scaling that renders large matrix-product-operator contractions prohibitive.

The numerical evidence collected throughout the manuscript makes the advantages of the patched approach clear. Whenever the tensor of interest develops strong ``localisation'', the rank of a single tensor-train representation becomes dictated by the most singular region.  pQTCI circumvents this ``one-size-fits-all'' limitation by assigning high rank only to those patches that actually need it.  In the two-dimensional Green's function benchmarks in \prettyref{sec:2DGreen}, for instance, as soon as the broadening parameter $\delta$ falls below about \(10^{-2}\), the number of floating-point parameters and the wall-clock time required by the patched approximation decrease by an order of magnitude compared with the standard QTCI. A similar gain appears in the bare susceptibility $\chi_0(\bq,i\omega)$ calculation in \prettyref{sec:bubbleCalc}, where the computational cost remains well below the one of the monolithic strategy.

Moreover, the patch paradigm shows its full strength in tensor contractions.  By expressing each factor in a product as a collection of low-rank patches, the contraction can be decomposed into many smaller and simpler tasks. For the element-wise product of two real-space Green's functions the patched routine delivers a speed-up of nearly ten on a single workstation; furthermore, it completes cases that a single contraction cannot even fit within the RAM memory availability.

A central practical question remains: how should one choose the cap
\(\chi_{\text{patch}}\)?  Our analysis has derived two sets of bounds, Eqs.~\eqref{eq:chiPatchBound} and~\eqref{eq:elemMulBound},\eqref{eq:worstBound}--\eqref{eq:averageBound}, that delimit the patch count required for the patched approximation and patched MPO-MPO contraction, respectively, to beat its monolithic counterpart.  These bounds are reassuring \emph{a
posteriori}: whenever the observed patch
number respects them, the patched scheme is indeed advantageous.
They bounds do not, however, determine \(\chi_{\text{patch}}\) \emph{a priori}. The numerical examples in Chap.~\ref{chap:results} suggest that the optimal cap is correlated with the ``sharpness'' (cf. \prettyref{fig:2DGreenErrorHeatmap}) of the function of interest, yet the relation is intricate and problem specific. For instance, if
the cap chosen is too small, the algorithm enters the ``\emph{over-patching}'' regime, where an explosion of tiny patches negates the
expected savings. Caps that are too large, on the other hand, converge to the same resources requirement of a single QTCI approximation (cf. Figs~\ref{fig:memoryTime2DGreenFused} and \ref{fig:memoryTime2DGreenFused}).

Establishing a predictive rule for the cap is therefore an important topic for future research.  Such a rule is likely to involve a refinement of the concept of $\varepsilon$–factorisable functions: just as
QTCI succeeds whenever the entire tensor admits a low-rank representation, pQTCI succeeds whenever the configuration space can be divided into a modest number of regions, each of which is well approximated at rank \(\chi_{\text{patch}}\). One may speak of \emph{$\varepsilon$–patch–
factorisable} functions and attempt to characterise their feature distributions analytically.

Looking at concrete applications, a natural next step starting from \prettyref{sec:bubbleCalc} is to transfer the patched-QTCI strategy from imaginary to real frequencies. Computing the retarded bare susceptibility $\chi^R_0(\bq,\omega)$ is famously delicate. The local error control and adaptive rank allocation built into pQTCI are well suited to tame these difficulties and should enable high-resolution calculations directly on the real-frequency axis. A second avenue (cf. \prettyref{sec:patchBSE}) is to apply the patch concept to vertex physics—specifically, to solve the Bethe-Salpeter equation with full momentum dependence. Because the kernel of a momentum-resolved BSE often contains sharply peaked structures that vary from one region of the Brillouin zone to another, distributing the calculation into rank-capped patches could reduce the overall contraction cost in much the same way it does for Green's-function products. Both extensions would further broaden the range of many-body problems that can be tackled efficiently within the QTCI framework.

Finally, the patching strategy is inherently parallel. At the time of writing, a parallel version of the state-of-the-art \texttt{crossinterpolate2} routine has be rendered available, and its capabilities dovetail naturally with the patched techniques introduced here. Because both pQTCI and the patched MPO-MPO algorithms break the workload into many independent, rank-capped subtasks, they lend themselves to \emph{distributed} execution (a first parallel implementation of the patched contraction scheme is already in place in the \href{https://tensor4all.org}{tensor4all.org} $\julia$ libraries colection). Harnessing the new internal parallelism of \texttt{crossinterpolate2} together with this external domain decomposition promises substantial additional speed-ups once the tuning between the two parallelisation schemes is optimised.
